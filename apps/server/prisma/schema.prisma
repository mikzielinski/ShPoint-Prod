generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_DATABASE_URL")
}

model User {
  id                   String                @id @default(cuid())
  email                String                @unique
  name                 String?
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  avatarUrl            String?
  role                 Role                  @default(USER)
  lastLoginAt          DateTime?
  status               UserStatus            @default(ACTIVE)
  image                String?
  passwordHash         String?
  invitedAt            DateTime?
  invitedBy            String?
  username             String?               @unique
  invitationsLimit     Int                   @default(0)
  invitationsSent      Int                   @default(0)
  lastInvitationSentAt DateTime?
  suspendedAt          DateTime?
  suspendedBy          String?
  suspendedReason      String?
  suspendedUntil       DateTime?
  cards                Card[]
  characterCollections CharacterCollection[]
  collections          Collection[]
  missionCollections   MissionCollection[]
  setCollections       SetCollection[]
  strikeTeams          StrikeTeam[]
  customCards          CustomMadeCard[]
  customCardShares     CustomCardShare[]
  customCardCollections CustomCardCollection[]
  auditLogs            AuditLog[]
  // Nowe relacje dla Shatterpoint
  createdCharacters    Character[] @relation("CharacterCreatedBy")
  updatedCharacters    Character[] @relation("CharacterUpdatedBy")
  
  // Comments system
  comments             Comment[] @relation("CommentAuthor")
  commentLikes         CommentLike[] @relation("CommentLikes")
  
  // Inbox system
  inboxMessages        InboxMessage[] @relation("InboxRecipient")
  sentMessages         InboxMessage[] @relation("InboxSender")
  
  // Challenge system
  challengesSent       Challenge[] @relation("ChallengeChallenger")
  challengesReceived   Challenge[] @relation("ChallengeChallenged")
  
  // Scheduled games
  gamesAsPlayer1       ScheduledGame[] @relation("ScheduledGamePlayer1")
  gamesAsPlayer2       ScheduledGame[] @relation("ScheduledGamePlayer2")
  gameReminders        GameReminder[] @relation("GameReminders")
  gameRegistrations    GameRegistration[] @relation("GameRegistrations")
  
  // Game results
  gameResultsAsPlayer1 GameResult[] @relation("GameResultPlayer1")
  gameResultsAsPlayer2 GameResult[] @relation("GameResultPlayer2")
  gameResultsWon       GameResult[] @relation("GameResultWinner")
  gameResultsReported  GameResult[] @relation("GameResultReportedBy")
  gameResultCharacters GameResultCharacter[] @relation("GameResultCharacterPlayer")
  characterStates CharacterState[] @relation("CharacterStatePlayer")
  diceRolls DiceRoll[] @relation("DiceRollPlayer")
  nodeActivations NodeActivation[] @relation("NodeActivationPlayer")
  // API Tokens
  apiTokens              ApiToken[]

  // Relations
  accessRequestsReviewed AccessRequest[] @relation("AccessRequestReviewedBy")
  invitationsSentRel UserInvitation[] @relation("UserInvitations")
  invitedByRel UserInvitation? @relation("UserInvitedBy")

  @@index([createdAt])
  @@index([email])
  @@index([username])
  @@index([role])
  @@index([status])
  @@index([suspendedUntil])
  @@index([suspendedBy])
  @@index([invitedBy])
  @@index([invitationsLimit])
}

model UserInvitation {
  id          String    @id @default(cuid())
  email       String    @unique
  invitedBy   String
  invitedAt   DateTime  @default(now())
  expiresAt   DateTime
  usedAt      DateTime?
  usedBy      String?   @unique
  
  // Relations
  inviter     User      @relation("UserInvitations", fields: [invitedBy], references: [id])
  user        User?     @relation("UserInvitedBy", fields: [usedBy], references: [id])
  
  @@index([email])
  @@index([invitedBy])
  @@index([expiresAt])
  @@index([usedAt])
}

model Card {
  id          String     @id @default(cuid())
  title       String
  slug        String     @unique
  body        Json?
  status      CardStatus @default(DRAFT)
  createdById String
  publishedAt DateTime?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  createdBy   User       @relation(fields: [createdById], references: [id])

  @@index([slug])
  @@index([status, publishedAt])
  @@index([createdAt])
}

model AllowedEmail {
  id        String    @id @default(cuid())
  email     String    @unique
  role      Role      @default(USER)
  invitedBy String?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  isActive  Boolean   @default(true)
  expiresAt DateTime?
  usedAt    DateTime?

  @@index([email])
  @@index([role])
  @@index([isActive])
  @@index([invitedBy])
  @@index([usedAt])
  @@index([expiresAt])
}

model SystemSettings {
  id          String   @id @default(cuid())
  key         String   @unique
  value       String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  updatedBy   String?

  @@index([key])
}

model Collection {
  id        String           @id @default(cuid())
  userId    String
  title     String?
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  items     CollectionItem[]

  @@index([userId])
  @@index([createdAt])
}

model CollectionItem {
  id           String     @id @default(cuid())
  collectionId String
  cardId       String
  status       ItemStatus @default(OWNED)
  notes        String?
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  collection   Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)

  @@unique([collectionId, cardId])
  @@index([collectionId])
  @@index([cardId])
  @@index([status])
}

model CharacterCollection {
  id          String   @id @default(cuid())
  userId      String
  characterId String
  notes       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  isFavorite  Boolean  @default(false)
  isOwned     Boolean  @default(false)
  isPainted   Boolean  @default(false)
  isSold      Boolean  @default(false)
  isWishlist  Boolean  @default(false)
  deaths      Int      @default(0)
  kills       Int      @default(0)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  character   Character @relation(fields: [characterId], references: [id], onDelete: Cascade)

  @@unique([userId, characterId])
  @@index([userId])
  @@index([characterId])
  @@index([isOwned])
  @@index([isPainted])
  @@index([isWishlist])
}

model SetCollection {
  id         String   @id @default(cuid())
  userId     String
  setId      String
  notes      String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  isFavorite Boolean  @default(false)
  isOwned    Boolean  @default(false)
  isPainted  Boolean  @default(false)
  isSold     Boolean  @default(false)
  isWishlist Boolean  @default(false)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  set        Set      @relation(fields: [setId], references: [id], onDelete: Cascade)

  @@unique([userId, setId])
  @@index([userId])
  @@index([setId])
  @@index([isOwned])
  @@index([isPainted])
  @@index([isWishlist])
}

model MissionCollection {
  id          String    @id @default(cuid())
  userId      String
  missionId   String
  notes       String?
  completedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  isCompleted Boolean   @default(false)
  isFavorite  Boolean   @default(false)
  isLocked    Boolean   @default(false)
  isOwned     Boolean   @default(false)
  isWishlist  Boolean   @default(false)
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  mission     Mission   @relation(fields: [missionId], references: [id], onDelete: Cascade)

  @@unique([userId, missionId])
  @@index([userId])
  @@index([missionId])
  @@index([isOwned])
  @@index([isCompleted])
  @@index([isWishlist])
}

model StrikeTeam {
  id          String                @id @default(cuid())
  userId      String
  name        String
  type        StrikeTeamType        @default(MY_TEAMS)
  description String?
  createdAt   DateTime              @default(now())
  updatedAt   DateTime              @updatedAt
  draws       Int                   @default(0)
  isPublished Boolean               @default(false)
  losses      Int                   @default(0)
  squad1Name  String                @default("Squad 1")
  squad2Name  String                @default("Squad 2")
  wins        Int                   @default(0)
  user        User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  characters  StrikeTeamCharacter[]
  
  // Challenge system relations
  challengesAsChallenger Challenge[] @relation("ChallengeChallengerTeam")
  gamesAsPlayer1Team     ScheduledGame[] @relation("ScheduledGamePlayer1Team")
  gamesAsPlayer2Team     ScheduledGame[] @relation("ScheduledGamePlayer2Team")
  
  // Game results relations
  gameResultsAsPlayer1Team GameResult[] @relation("GameResultPlayer1Team")
  gameResultsAsPlayer2Team GameResult[] @relation("GameResultPlayer2Team")

  @@index([userId])
  @@index([type])
  @@index([isPublished])
}

model StrikeTeamCharacter {
  id            String        @id @default(cuid())
  strikeTeamId  String
  characterId   String
  role          CharacterRole
  order         Int
  createdAt     DateTime      @default(now())
  characterName String?
  unitCount     Int           @default(1)
  strikeTeam    StrikeTeam    @relation(fields: [strikeTeamId], references: [id], onDelete: Cascade)
  character     Character     @relation(fields: [characterId], references: [id], onDelete: Cascade)

  @@unique([strikeTeamId, characterId])
  @@index([strikeTeamId])
  @@index([characterId])
  @@index([characterName])
}

enum Role {
  USER
  ADMIN
  EDITOR
  GUEST
  API_USER
}

enum UserStatus {
  ACTIVE
  SUSPENDED
}

enum CardStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

enum ItemStatus {
  OWNED
  PAINTED
  WISHLIST
}

enum CollectionStatus {
  OWNED
  PAINTED
  WISHLIST
  SOLD
  FAVORITE
}

enum StrikeTeamType {
  MY_TEAMS
  DREAM_TEAMS
}

enum CharacterRole {
  PRIMARY
  SECONDARY
  SUPPORT
}

enum CustomCardStatus {
  DRAFT
  PUBLISHED
  SHARED
}

model CustomMadeCard {
  id            String            @id @default(cuid())
  name          String
  description   String?
  faction       String
  unitType      CharacterRole
  squadPoints   Int
  stamina       Int
  durability    Int
  force         Int?
  hanker        Int?
  
  // Card data (JSON)
  abilities     Json?             // Array of abilities with names, descriptions, icons
  stances       Json?             // Array of stances with attack/defense data
  portrait      String?           // Base64 encoded image or URL
  
  // Metadata
  status        CustomCardStatus  @default(DRAFT)
  isPublic      Boolean           @default(false)
  authorId      String
  author        User              @relation(fields: [authorId], references: [id], onDelete: Cascade)
  
  // Sharing
  sharedWith    CustomCardShare[]
  collections   CustomCardCollection[]
  
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  
  @@index([authorId])
  @@index([status])
  @@index([isPublic])
  @@index([faction])
  @@index([unitType])
}

model CustomCardShare {
  id            String        @id @default(cuid())
  cardId        String
  card          CustomMadeCard @relation(fields: [cardId], references: [id], onDelete: Cascade)
  sharedWithId  String
  sharedWith    User          @relation(fields: [sharedWithId], references: [id], onDelete: Cascade)
  accepted      Boolean       @default(false)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  
  @@unique([cardId, sharedWithId])
  @@index([cardId])
  @@index([sharedWithId])
  @@index([accepted])
}

model CustomCardCollection {
  id            String        @id @default(cuid())
  userId        String
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  cardId        String
  card          CustomMadeCard @relation(fields: [cardId], references: [id], onDelete: Cascade)
  isOwned       Boolean       @default(false)
  isPainted     Boolean       @default(false)
  isWishlist    Boolean       @default(false)
  isFavorite    Boolean       @default(false)
  notes         String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  
  @@unique([userId, cardId])
  @@index([userId])
  @@index([cardId])
  @@index([isOwned])
  @@index([isPainted])
  @@index([isWishlist])
}

model AuditLog {
  id          String      @id @default(cuid())
  entityType  EntityType
  entityId    String
  action      AuditAction
  userId      String?
  user        User?       @relation(fields: [userId], references: [id], onDelete: SetNull)
  changes     Json?       // Before/after values
  description String?
  ipAddress   String?
  userAgent   String?
  createdAt   DateTime    @default(now())
  
  @@index([entityType, entityId])
  @@index([userId])
  @@index([action])
  @@index([createdAt])
}

enum EntityType {
  USER
  CARD
  CHARACTER
  MISSION
  SET
  STRIKE_TEAM
  CUSTOM_CARD
  COLLECTION
  SYSTEM_SETTINGS
  SECURITY
  API_TOKEN
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
  LOGIN
  LOGOUT
  ROLE_CHANGE
  STATUS_CHANGE
  PUBLISH
  UNPUBLISH
  SHARE
  UNSHARE
  DDOS_DETECTED
}

// ===== SHATTERPOINT GAME DATA MODELS =====

model Character {
  id                String   @id @default(cuid())
  name              String
  slug              String   @unique
  faction           String
  unitType          String   // Primary, Secondary, Support
  squadPoints       Int
  stamina           Int
  durability        Int
  force             Int?
  hanker            Int?
  boxSetCode        String?
  characterNames    String
  numberOfCharacters Int     @default(1)
  
  // Era i okresy
  era               String[]
  period            String[]
  tags              String[]
  factions          String[]
  
  // Obrazy - zoptymalizowane dla szybkiego ładowania
  portraitUrl       String?
  imageUrl          String?
  
  // Relacje - eager loading optimization
  abilities         CharacterAbility[]
  stances           CharacterStance[]
  characterCollections CharacterCollection[]
  strikeTeamCharacters StrikeTeamCharacter[]
  setCharacters     SetCharacter[]
  gameResultCharacters GameResultCharacter[]
  characterStates CharacterState[]
  diceRolls DiceRoll[]
  nodeActivations NodeActivation[]
  diceRollsAsSource DiceRoll[] @relation("DiceRollTarget")
  nodeActivationsAsTarget NodeActivation[] @relation("NodeActivationTarget")
  
  // Metadata z wersjonowaniem
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  createdBy         String?  // ID użytkownika który dodał
  updatedBy         String?  // ID użytkownika który ostatnio edytował
  version           Int      @default(1)
  isActive          Boolean  @default(true)
  
  // Relacje do User
  createdByUser     User?    @relation("CharacterCreatedBy", fields: [createdBy], references: [id])
  updatedByUser     User?    @relation("CharacterUpdatedBy", fields: [updatedBy], references: [id])
  
  // Indeksy dla szybkiego wyszukiwania
  @@index([faction])
  @@index([unitType])
  @@index([boxSetCode])
  @@index([isActive])
  @@index([name])
  @@index([squadPoints])
  @@index([createdAt])
  @@index([updatedAt])
}

model CharacterAbility {
  id            String   @id @default(cuid())
  characterId   String
  character     Character @relation(fields: [characterId], references: [id], onDelete: Cascade)
  
  name          String
  type          String   // Active, Reactive, Innate
  symbol        String
  trigger       String
  isAction      Boolean  @default(false)
  forceCost     Int      @default(0)
  damageCost    Int      @default(0)
  description   String
  tags          String[]
  
  // Legacy support dla kompatybilności
  legacyText    String?
  legacyTitle   String?
  
  // Metadata
  order         Int      @default(0)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // Indeksy dla szybkiego ładowania
  @@index([characterId])
  @@index([type])
  @@index([order])
  @@index([characterId, order]) // Composite index dla sortowania
}

model CharacterStance {
  id            String   @id @default(cuid())
  characterId   String
  character     Character @relation(fields: [characterId], references: [id], onDelete: Cascade)
  
  // Dice data - zoptymalizowane dla szybkiego dostępu
  attackDice    Int
  defenseDice   Int
  
  // Expertise
  meleeExpertise Int
  rangedExpertise Int
  
  // Tree structure - JSON z optymalizacją
  tree          Json     // Array of arrays representing stance tree
  // Przykład: [["start"], ["melee_attack", "ranged_attack"], ["damage", "damage"]]
  
  // Metadata
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // Indeksy
  @@index([characterId])
  @@unique([characterId]) // Jeden stance per character
}

model Set {
  id            String   @id @default(cuid())
  name          String
  code          String   @unique // SWP01, SWP03, etc.
  type          SetType
  description   String?
  productUrl    String?
  imageUrl      String?
  
  // Relacje
  characters    SetCharacter[]
  setCollections SetCollection[]
  
  // Metadata
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  isActive      Boolean  @default(true)
  
  // Indeksy dla szybkiego wyszukiwania
  @@index([code])
  @@index([type])
  @@index([isActive])
  @@index([name])
}

model SetCharacter {
  id            String   @id @default(cuid())
  setId         String
  set           Set      @relation(fields: [setId], references: [id], onDelete: Cascade)
  characterId   String?  // Może być null jeśli postać nie istnieje jeszcze
  character     Character? @relation(fields: [characterId], references: [id])
  
  role          CharacterRole // Primary, Secondary, Supporting
  name          String        // Nazwa postaci w kontekście setu
  
  // Indeksy
  @@unique([setId, characterId])
  @@index([setId])
  @@index([characterId])
  @@index([role])
}

model Mission {
  id            String   @id @default(cuid())
  name          String
  source        String   // official, custom
  setCode       String?
  description   String?
  thumbnailUrl  String?
  
  // Map data - zoptymalizowane
  mapSizeInch   Int
  mapUnit       String
  mapOrigin     String
  mapAxis       String
  
  // Rendering data
  pointDiameterInch Float
  
  // Scheduled games relation
  scheduledGames ScheduledGame[]
  
  // Game results relation
  gameResults GameResult[]
  
  // Game sessions relation
  gameSessions GameSession[]
  pointColorActive  String
  pointColorInactive String
  
  // Relacje
  objectives    MissionObjective[]
  struggles     MissionStruggle[]
  missionCollections MissionCollection[]
  
  // Metadata
  tags          String[]
  notes         String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  isActive      Boolean  @default(true)
  
  // Indeksy
  @@index([source])
  @@index([setCode])
  @@index([isActive])
  @@index([name])
}

model MissionObjective {
  id            String   @id @default(cuid())
  missionId     String
  mission       Mission  @relation(fields: [missionId], references: [id], onDelete: Cascade)
  
  key           String   // A, B, C, etc.
  x             Float
  y             Float
  radius        Float
  
  // Indeksy
  @@index([missionId])
  @@index([missionId, key]) // Composite dla szybkiego dostępu
}

model MissionStruggle {
  id            String   @id @default(cuid())
  missionId     String
  mission       Mission  @relation(fields: [missionId], references: [id], onDelete: Cascade)
  
  index         Int      // 1, 2, 3
  cards         Json     // Array of struggle cards
  
  // Indeksy
  @@index([missionId])
  @@index([missionId, index]) // Composite dla sortowania
}

// ===== COMMENTS SYSTEM =====

model Comment {
  id          String      @id @default(cuid())
  content     String
  type        CommentType
  entityId    String      // ID of the entity being commented on
  authorId    String
  author      User        @relation("CommentAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  isDeleted   Boolean     @default(false)
  deletedAt   DateTime?
  deletedBy   String?
  likes       CommentLike[]
  replies     Comment[]   @relation("CommentReplies")
  parentId    String?
  parent      Comment?    @relation("CommentReplies", fields: [parentId], references: [id])
  
  @@index([type, entityId])
  @@index([authorId])
  @@index([createdAt])
}

model CommentLike {
  id        String   @id @default(cuid())
  commentId String
  comment   Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation("CommentLikes", fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  
  @@unique([commentId, userId])
  @@index([userId])
}

// ===== INBOX SYSTEM =====

model InboxMessage {
  id          String   @id @default(cuid())
  recipientId String
  recipient   User     @relation("InboxRecipient", fields: [recipientId], references: [id], onDelete: Cascade)
  senderId    String?
  sender      User?    @relation("InboxSender", fields: [senderId], references: [id], onDelete: SetNull)
  type        String   // "challenge", "game_invite", "system", etc.
  title       String
  content     String
  isRead      Boolean  @default(false)
  readAt      DateTime?
  createdAt   DateTime @default(now())
  data        Json?    // Additional data for the message
  
  @@index([recipientId, isRead])
  @@index([createdAt])
}

// ===== CHALLENGE SYSTEM =====

model Challenge {
  id              String          @id @default(cuid())
  challengerId    String
  challenger      User            @relation("ChallengeChallenger", fields: [challengerId], references: [id], onDelete: Cascade)
  challengedId    String
  challenged      User            @relation("ChallengeChallenged", fields: [challengedId], references: [id], onDelete: Cascade)
  status          ChallengeStatus @default(PENDING)
  skillLevel      SkillLevel
  preferredMissions String[]      // Array of mission IDs
  challengerStrikeTeamId String?
  challengerStrikeTeam StrikeTeam? @relation("ChallengeChallengerTeam", fields: [challengerStrikeTeamId], references: [id])
  language        String          @default("en")
  location        String?
  address         String?
  reservationCost Decimal?        @db.Decimal(10, 2)
  description     String?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  acceptedAt      DateTime?
  declinedAt      DateTime?
  cancelledAt     DateTime?
  completedAt     DateTime?
  scheduledGame   ScheduledGame?
  
  @@index([challengerId])
  @@index([challengedId])
  @@index([status])
  @@index([createdAt])
}

// ===== SCHEDULED GAMES =====

model ScheduledGame {
  id              String        @id @default(cuid())
  challengeId     String        @unique
  challenge       Challenge     @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  player1Id       String
  player1         User          @relation("ScheduledGamePlayer1", fields: [player1Id], references: [id], onDelete: Cascade)
  player2Id       String
  player2         User          @relation("ScheduledGamePlayer2", fields: [player2Id], references: [id], onDelete: Cascade)
  status          GameStatus    @default(SCHEDULED)
  scheduledDate   DateTime
  location        String?
  address         String?
  missionId       String?
  mission         Mission?      @relation(fields: [missionId], references: [id])
  player1StrikeTeamId String?
  player1StrikeTeam StrikeTeam? @relation("ScheduledGamePlayer1Team", fields: [player1StrikeTeamId], references: [id])
  player2StrikeTeamId String?
  player2StrikeTeam StrikeTeam? @relation("ScheduledGamePlayer2Team", fields: [player2StrikeTeamId], references: [id])
  notes           String?
  isPublic        Boolean       @default(false)  // Whether the game is open for public registration
  maxPlayers      Int?          @default(2)      // Maximum number of players (for public games)
  city            String?       // City where game takes place
  country         String?       // Country where game takes place
  skillLevel      String?       // BEGINNER, INTERMEDIATE, ADVANCED, PRO
  isPaid          Boolean       @default(false)  // Whether reservation requires payment
  totalCost       Float?        // Total cost for the game
  currency        String?       @default("PLN")  // Currency code (PLN, EUR, USD, GBP)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  confirmedAt     DateTime?
  startedAt       DateTime?
  completedAt     DateTime?
  cancelledAt     DateTime?
  reminders       GameReminder[]
  gameResult      GameResult?
  registrations   GameRegistration[]
  
  @@index([player1Id])
  @@index([player2Id])
  @@index([scheduledDate])
  @@index([status])
  @@index([isPublic])
  @@index([city])
  @@index([country])
  @@index([city, country])
}

model GameReminder {
  id              String        @id @default(cuid())
  gameId          String
  game            ScheduledGame @relation(fields: [gameId], references: [id], onDelete: Cascade)
  userId          String
  user            User          @relation("GameReminders", fields: [userId], references: [id], onDelete: Cascade)
  type            ReminderType
  reminderTime    DateTime
  isSent          Boolean       @default(false)
  isEnabled       Boolean       @default(true)  // Whether the reminder is enabled
  sentAt          DateTime?
  calendarEventId String?       // For tracking calendar events
  createdAt       DateTime      @default(now())
  
  @@index([gameId])
  @@index([userId])
  @@index([reminderTime])
}

model GameRegistration {
  id              String        @id @default(cuid())
  gameId          String
  game            ScheduledGame @relation(fields: [gameId], references: [id], onDelete: Cascade)
  userId          String
  user            User          @relation("GameRegistrations", fields: [userId], references: [id], onDelete: Cascade)
  status          GameRegistrationStatus @default(PENDING)
  registeredAt    DateTime      @default(now())
  approvedAt      DateTime?
  rejectedAt      DateTime?
  waitlistPosition Int?         // Position in waitlist (null if not on waitlist)
  notes           String?
  
  @@unique([gameId, userId])
  @@index([gameId])
  @@index([userId])
  @@index([status])
  @@index([waitlistPosition])
}

enum GameRegistrationStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
  WAITLIST
}

// ===== GAME RESULTS SYSTEM =====

model GameResult {
  id              String        @id @default(cuid())
  player1Id       String
  player1         User          @relation("GameResultPlayer1", fields: [player1Id], references: [id], onDelete: Cascade)
  player2Id       String
  player2         User          @relation("GameResultPlayer2", fields: [player2Id], references: [id], onDelete: Cascade)
  winnerId        String?
  winner          User?         @relation("GameResultWinner", fields: [winnerId], references: [id], onDelete: SetNull)
  result          GameResultType
  mode            GameMode      @default(CASUAL)
  missionId       String?
  mission         Mission?      @relation(fields: [missionId], references: [id])
  
  // Strike teams used
  player1StrikeTeamId String?
  player1StrikeTeam   StrikeTeam? @relation("GameResultPlayer1Team", fields: [player1StrikeTeamId], references: [id])
  player2StrikeTeamId String?
  player2StrikeTeam   StrikeTeam? @relation("GameResultPlayer2Team", fields: [player2StrikeTeamId], references: [id])
  
  // Game details
  roundsPlayed    Int           @default(1)
  durationMinutes Int?
  location        String?
  notes           String?
  
  // Related scheduled game (if any)
  scheduledGameId String?       @unique
  scheduledGame   ScheduledGame? @relation(fields: [scheduledGameId], references: [id])
  
  // Timestamps
  playedAt        DateTime      @default(now())
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  // Reported by
  reportedById    String
  reportedBy      User          @relation("GameResultReportedBy", fields: [reportedById], references: [id], onDelete: Cascade)
  
  // Verification
  isVerified      Boolean       @default(false)
  verifiedAt      DateTime?
  verifiedBy      String?
  
  // Character performance
  characterResults GameResultCharacter[]
  
  // Detailed game session
  gameSession GameSession?
  
  @@index([player1Id])
  @@index([player2Id])
  @@index([winnerId])
  @@index([playedAt])
  @@index([mode])
  @@index([missionId])
}

model GameResultCharacter {
  id            String      @id @default(cuid())
  gameResultId  String
  gameResult    GameResult  @relation(fields: [gameResultId], references: [id], onDelete: Cascade)
  characterId   String
  character     Character   @relation(fields: [characterId], references: [id], onDelete: Cascade)
  playerId      String
  player        User        @relation("GameResultCharacterPlayer", fields: [playerId], references: [id], onDelete: Cascade)
  
  // Character performance
  damageDealt   Int         @default(0)
  damageTaken   Int         @default(0)
  abilitiesUsed Int         @default(0)
  objectivesSecured Int     @default(0)
  isMVP         Boolean     @default(false)
  
  @@index([gameResultId])
  @@index([characterId])
  @@index([playerId])
}

// ===== DETAILED GAME LOGGING =====

model GameSession {
  id              String        @id @default(cuid())
  gameResultId    String        @unique
  gameResult      GameResult    @relation(fields: [gameResultId], references: [id], onDelete: Cascade)
  
  // Mission and setup
  missionId       String
  mission         Mission       @relation(fields: [missionId], references: [id])
  
  // Starting positions and setup
  startingPositions Json        // Starting positions for both players
  setupData       Json?         // Additional setup information
  
  // Game state
  currentTier     StruggleTier  @default(TIER_1)
  isActive        Boolean       @default(true)
  
  // Timestamps
  startedAt       DateTime      @default(now())
  completedAt     DateTime?
  
  // Related data
  struggleCards   StruggleCard[]
  characterStates CharacterState[]
  diceRolls       DiceRoll[]
  nodeActivations NodeActivation[]
  
  @@index([gameResultId])
  @@index([missionId])
  @@index([startedAt])
}

model StruggleCard {
  id              String        @id @default(cuid())
  gameSessionId   String
  gameSession     GameSession   @relation(fields: [gameSessionId], references: [id], onDelete: Cascade)
  
  tier            StruggleTier
  cardName        String
  cardDescription String?
  cardImageUrl    String?
  
  // Card selection
  selectedBy      String?       // Player ID who selected this card
  isActive        Boolean       @default(false)
  isCompleted     Boolean       @default(false)
  
  // Results
  winnerId        String?       // Player ID who won this struggle
  result          GameResultType
  
  // Timestamps
  selectedAt      DateTime      @default(now())
  completedAt     DateTime?
  
  @@index([gameSessionId])
  @@index([tier])
  @@index([selectedBy])
}

model CharacterState {
  id              String        @id @default(cuid())
  gameSessionId   String
  gameSession     GameSession   @relation(fields: [gameSessionId], references: [id], onDelete: Cascade)
  
  characterId     String
  character       Character     @relation(fields: [characterId], references: [id], onDelete: Cascade)
  playerId        String
  player          User          @relation("CharacterStatePlayer", fields: [playerId], references: [id], onDelete: Cascade)
  
  // Current stats
  currentStamina  Int
  currentDurability Int
  currentForce    Int?
  currentHanker   Int?
  
  // Status effects
  status          CharacterStatus @default(NORMAL)
  statusDuration  Int?           // How many rounds the status lasts
  
  // Performance tracking
  damageDealt     Int           @default(0)
  damageTaken     Int           @default(0)
  abilitiesUsed   Int           @default(0)
  objectivesSecured Int         @default(0)
  isMVP           Boolean       @default(false)
  
  // Position tracking
  currentPosition Json?         // Current position on the map
  
  // Timestamps
  updatedAt       DateTime      @updatedAt
  
  @@index([gameSessionId])
  @@index([characterId])
  @@index([playerId])
  @@index([status])
}

// ===== DICE ROLLS AND NODE ACTIVATION =====

model DiceRoll {
  id              String        @id @default(cuid())
  gameSessionId   String
  gameSession     GameSession   @relation(fields: [gameSessionId], references: [id], onDelete: Cascade)
  
  characterId     String
  character       Character     @relation(fields: [characterId], references: [id], onDelete: Cascade)
  playerId        String
  player          User          @relation("DiceRollPlayer", fields: [playerId], references: [id], onDelete: Cascade)
  
  // Dice information
  diceType        DiceType
  diceCount       Int           // Number of dice rolled
  diceResults     DiceResult[]  // Array of individual dice results
  
  // Context
  action          String?       // What action triggered this roll (e.g., "Melee Attack", "Force Push")
  targetCharacterId String?     // Target character if applicable
  targetCharacter Character?    @relation("DiceRollTarget", fields: [targetCharacterId], references: [id])
  
  // Modifiers
  modifiers       Json?         // Any modifiers applied (rerolls, bonuses, etc.)
  finalResult     String?       // Final calculated result
  
  // Timestamps
  rolledAt        DateTime      @default(now())
  
  @@index([gameSessionId])
  @@index([characterId])
  @@index([playerId])
  @@index([diceType])
  @@index([rolledAt])
}

model NodeActivation {
  id              String        @id @default(cuid())
  gameSessionId   String
  gameSession     GameSession   @relation(fields: [gameSessionId], references: [id], onDelete: Cascade)
  
  characterId     String
  character       Character     @relation(fields: [characterId], references: [id], onDelete: Cascade)
  playerId        String
  player          User          @relation("NodeActivationPlayer", fields: [playerId], references: [id], onDelete: Cascade)
  
  // Node information
  nodePath        String        // Path to the node in the stance tree (e.g., "0.1.2")
  nodeName        String        // Name/description of the node
  nodeEffects     Json          // Effects of the node (damage, conditions, etc.)
  
  // Activation context
  activationType  String        // "MANUAL" or "AUTOMATIC"
  triggerAction   String?       // What action triggered this activation
  targetCharacterId String?     // Target character if applicable
  targetCharacter Character?    @relation("NodeActivationTarget", fields: [targetCharacterId], references: [id])
  
  // Results
  effectsApplied  Json?         // What effects were actually applied
  damageDealt     Int?          // Damage dealt if applicable
  conditionsApplied String[]    // Conditions applied (strain, pinned, etc.)
  
  // Timestamps
  activatedAt     DateTime      @default(now())
  
  @@index([gameSessionId])
  @@index([characterId])
  @@index([playerId])
  @@index([activationType])
  @@index([activatedAt])
}

// ===== ACCESS REQUESTS SYSTEM =====

model AccessRequest {
  id              String        @id @default(cuid())
  email           String        @unique
  name            String?
  message         String?
  status          AccessRequestStatus @default(PENDING)
  
  // Timestamps
  requestedAt     DateTime      @default(now())
  reviewedAt      DateTime?
  reviewedBy      String?       // Admin user ID who reviewed
  
  // Review notes
  reviewNotes     String?
  
  // Reviewed by admin
  reviewedByUser  User?         @relation("AccessRequestReviewedBy", fields: [reviewedBy], references: [id])
  
  @@index([email])
  @@index([status])
  @@index([requestedAt])
}

// ===== ENUMS =====

enum SetType {
  CORE_SET
  SQUAD_PACK
  TERRAIN_PACK
  DUEL_PACK
  MISSION_PACK
  ACCESSORIES
}

enum CommentType {
  CHARACTER
  STRIKE_TEAM
  SET
  MISSION
}

enum ChallengeStatus {
  PENDING
  ACCEPTED
  DECLINED
  CANCELLED
  COMPLETED
}

enum SkillLevel {
  BEGINNER
  INTERMEDIATE
  ADVANCED
  EXPERT
  PRO
}

enum GameStatus {
  SCHEDULED
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum ReminderType {
  EMAIL
  PUSH_NOTIFICATION
  BOTH
}

enum GameResultType {
  WIN
  LOSS
  DRAW
}

enum GameMode {
  CASUAL
  RANKED
  TOURNAMENT
  FRIENDLY
}

enum StruggleTier {
  TIER_1
  TIER_2
  TIER_3
}

enum CharacterStatus {
  STRAIN
  PINNED
  EXPOSE
  DISARM
  NORMAL
}

enum DiceType {
  ATTACK
  DEFENSE
  EXPERTISE
  FORCE
  DAMAGE
}

enum DiceResult {
  HIT
  CRIT
  BLOCK
  EVADE
  EXPERTISE_SUCCESS
  EXPERTISE_FAIL
  FORCE_SUCCESS
  FORCE_FAIL
  DAMAGE_SUCCESS
  DAMAGE_FAIL
}

enum AccessRequestStatus {
  PENDING
  APPROVED
  REJECTED
}

model ApiToken {
  id          String    @id @default(cuid())
  name        String    // User-friendly name for the token
  token       String    @unique // The actual bearer token
  userId      String
  isActive    Boolean   @default(true)
  lastUsedAt  DateTime?
  expiresAt   DateTime?
  scopes      String[]  @default([]) // Array of permissions/scopes
  
  // Timestamps
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  // Relations
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([token])
  @@index([isActive])
  @@index([expiresAt])
}
